#version 460
layout (local_size_x = 8, local_size_y = 8) in;

layout (rgba32f, binding = 0) uniform image2D outImage;

uniform vec2 resolution;
uniform float time;
uniform float fractalLod;
uniform vec3 rayPos; 
uniform vec3 rayDir; 
uniform vec3 camUp;  
uniform vec3 camRight; 

const float MAX_DIST_F = 100.0;
const float MIN_DIST_F = 0.001;
const int MAX_STEPS = 512;
const int MAX_ITER = 64;

const float FOV_RAD = 1.0471975512; // 60 degrees in radians
const float FOCAL_LENGTH = 1.0 / tan(FOV_RAD * 0.5); // 1.0 / tan(30 deg) â‰ˆ 1.732

float mandelbulbDE(vec3 pos) {
    vec3 z = pos;
    float dr = 1.0;
    float r = 0.0;
    float bailout = 20.0;
    float power = 8.0;

    for (int i = 0; i < MAX_ITER; ++i) {
        r = length(z);
        if (r > bailout) break;

        float theta = acos(clamp(z.z / r, -1.0, 1.0));
        float phi = atan(z.y, z.x);

        dr = pow(r, power - 1.0) * power * dr + 1.0;
        float zr = pow(r, power);

        theta *= power;
        phi *= power;

        z = zr * vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta)) + pos;
    }

    return 0.5 * log(max(r, 1e-6)) * r / dr;
}

void main() {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    if (pix.x >= int(resolution.x) || pix.y >= int(resolution.y)) return;

    vec2 uv = (vec2(pix) / resolution) * 2.0 - 1.0;
    uv.x *= resolution.x / resolution.y;

    vec3 ray = normalize(rayDir * FOCAL_LENGTH + camRight * uv.x + camUp * uv.y);

    float total = 0.0;
    float maxDist = MAX_DIST_F;
    float minDist = MIN_DIST_F / (1.0 + fractalLod * 0.5);

    vec3 p;
    int steps = 0;
    for (int i = 0; i < MAX_STEPS; ++i) {
        p = rayPos + ray * total; 
        float d = mandelbulbDE(p);
        if (d < minDist) break;
        total += d;
        steps++;
        if (total > maxDist) break;
    }

    vec4 color;
    if (total < maxDist) {
        vec3 n = normalize(vec3(
            mandelbulbDE(p + vec3(1e-3,0,0)) - mandelbulbDE(p - vec3(1e-3,0,0)),
            mandelbulbDE(p + vec3(0,1e-3,0)) - mandelbulbDE(p - vec3(0,1e-3,0)),
            mandelbulbDE(p + vec3(0,0,1e-3)) - mandelbulbDE(p - vec3(0,0,1e-3))
        ));
        float diff = max(0.0, dot(n, normalize(vec3(1.0, 1.0, 1.0))));
        vec3 base = 0.5 + 0.5 * cos(p * 0.15 + vec3(0.0, 0.6, 1.2));
        float ao = 1.0 - float(steps) / float(MAX_STEPS);
        color = vec4(base * (0.2 + 0.8 * diff) * (0.5 + 0.5 * ao), 1.0);
    } else {
        color = vec4(0.02, 0.05, 0.08, 1.0);
    }

    imageStore(outImage, pix, color);
}